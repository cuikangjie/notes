<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>笔记 by kin</title><link rel="stylesheet" href="https://cuikangjie.github.io/blog-kin/lib/css/all.min.css"><link rel="icon" href="https://cuikangjie.github.io//blog-kin/lib/img/title.ico" type="image/x-icon"></head><body><div class="left-main"><div class="own-img"><a href="https://cuikangjie.github.io/resume/"><img src="https://cuikangjie.github.io//blog-kin/lib/img/kin.png"></a></div><div class="own-name"><a href="https://cuikangjie.github.io/resume/">kin</a></div><div class="own-main" id="num"></div><div class="own-addr" id="addr"></div><div class="own-share"><a href="https://github.com/cuikangjie" target="_blank"><img src="https://cuikangjie.github.io//blog-kin/lib/img/github.png"></a><a href="https://cuikangjie.github.io//blog-kin/"><img src="https://cuikangjie.github.io//blog-kin/lib/img/biji.png"></a><a href="http://www.cnblogs.com/kin-jie/"><img src="https://cuikangjie.github.io//blog-kin/lib/img/blog.png"></a><a href="http://www.jianshu.com/users/9fc42ce7c150/latest_articles"><img src="https://cuikangjie.github.io//blog-kin/lib/img/jian.png"></a><a href="mailto:cuikangjie_90h@126.com"><img src="https://cuikangjie.github.io//blog-kin/lib/img/email.png"></a><a href="javascript:window.print();"><img src="https://cuikangjie.github.io//blog-kin/lib/img/print.png"></a></div></div><div class="right-main"><h3 id="-">执行环境以及作用域</h3><p>执行环境（execution context）</p><ul><li>全局执行环境</li><li>局部执行环境（函数内）</li></ul><pre><code class="lang-javascript"> var color = &#39;red&#39;;
 var changeColor = function(){
    var anthorColor = &#39;white&#39;
    if(color === &#39;red&#39;){
      color=&#39;blue&#39;;
    }
  }
  console.log(color) // red  全局

  changeColor();

  console.log(color); //blue

  console.log(anthorColor); // 报错
</code></pre><blockquote><p>color属于全局环境，再调用changeColor函数后，生成一个作用域链， 在changeColor函数内调用color时，在changeColor作用域内并没有color,但它可以通过 作用域链访问外部环境的变量（全局环境）。</p><p>changeColor() 作用域内声明了变量anthorColor,只有在changeColor()作用域内才可以访问anthorColor .所以在全局作用域内输出 anthorColor 会报错</p></blockquote><hr><h3 id="-">变量声明</h3><blockquote><p>使用 var 声明任何数据类型的变量</p></blockquote><pre><code class="lang-javascript"> var str = &#39;string&#39;;
 var num = 12;
</code></pre><blockquote><p>在es6之前，没有块级作用域变量的声明，es6语法中增加了 let和const 声明变量的方法</p></blockquote><p>let 和 var 之间的真正区别是什么？</p><ul><li><p>let 变量是有块作用域的。用 let 定义的变量作用域只是封闭块，而不是整个封闭函数。现在仍有 let 变量提升，但是不再是随意提升。在 TherunTowerExperiment 例子中，可以用把 var 替换成 let 的方法来进行简单修复。如果你在每个地方都是使用的 let，你就不会有这种错误。</p></li><li><p>全局 let 变量不是全局对象的属性。也就是说，你不能通过写 window.variableName 访问它们。相反，它们存在于一个无形块作用域内，我们可以想象成一个网页运行的所有的 JS 代码都被封闭在了一起。</p></li><li><p>for (let x...)循环形式在每个迭代中都为 x 创建了一个新鲜的捆绑。</p></li></ul><blockquote><p>const使用 定义一个常量，不可以重新定义和改变</p></blockquote><pre><code class="lang-javascript">const MAX_CAT_SIZE_KG = 3000;
MAX_CAT_SIZE_KG = 5000; // 报错
MAX_CAT_SIZE_KG++; // 报错
</code></pre><hr><h3 id="-">数据类型</h3></div><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script src="https://cuikangjie.github.io/blog-kin/lib/js/all.min.js"></script></body></html>